# 深入webpack原理

> 标签：  前端; JS; webpack; ES6;



> 原文链接：[webpack原理](https://link.juejin.im/?target=http%3A%2F%2Fwebpack.wuhaolin.cn%2F5%25E5%258E%259F%25E7%2590%2586%2F)。
>
> 阅读原文记录的笔记



## 工作原理概括

### 基本概念

Webpack有几个基本的概念是需要掌握的，这样才能熟练的配置Webpack。

* `Entry` ： 入口，Webpack 执行构建的第一步将从`Entry`开始，也就是整个程序的入口文件。
* `Module`： 模块。在Webpack里面一切皆模块，一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归的找出所有依赖的模块。
* `Chunk` ： 代码块，一个 Chunk 由多个模块组合而成，用于代码合并和分割。
* `Loader`： 模块转换器，用于把模块原内容按照需求转换成新内容。
* `Plugin`：扩展插件，在 Webpack 构建流程中的特定时机会**广播出对应的事件**，插件可以**监听这些事件**的发生，在特定时机做对应的事情。

### 流程概括

Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：

1. **初始化参数**：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；
2. **开始编译**：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；
3. **确定入口**：根据配置中的 entry 找出所有的入口文件；
4. **编译模块**：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；
5. **完成模块编译**：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；
6. **输出资源**：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；
7. **输出完成**：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。

在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。

### 流程细节

Webpack 的构建流程可以分为以下三大阶段：

1. 初始化：启动构建，读取与合并并配置参数，加载Plugin，实例化Compiler。
2. 编译：从`Entry`开始，针对每个`Module`串行调用相应的`Loader`去翻译文件内容，再找到该`Module`依赖的`Module`，递归地进行编译处理。
3. 输出：对编译后的`Module`组合撑`Chunk`，把`Chunk`转换成文件，输出到文件系统。



如果只执行一次构建，上面的阶段按顺序执行一次。如果在开启监听的名模式下，流程将变成：

```mermaid
graph TB
	A[初始化] --> B[编译]
	B --> C[输出]
	C -- 监听变化 --> A
```

在每个大阶段中又会发生很多事件，Webpack 会把这些事件广播出来供给 Plugin 使用，下面来一一介绍。

### 初始化阶段

| 事件名            | 解释                                                         |
| ----------------- | ------------------------------------------------------------ |
| 初始化参数        | 从配置文件和 Shell 语句中读取与合并参数，得出最终的参数。 这个过程中还会执行配置文件中的插件实例化语句 `new Plugin()`。 |
| 实例化 `Compiler` | 用上一步得到的参数初始化 `Compiler` 实例，`Compiler` 负责文件监听和启动编译。`Compiler` 实例中包含了完整的 `Webpack` 配置，全局只有一个 `Compiler` 实例。 |
| 加载插件          | 依次调用插件的 `apply` 方法，让插件可以监听后续的所有事件节点。同时给插件传入 `compiler` 实例的引用，以方便插件通过 `compiler` 调用 Webpack 提供的 API。 |
| `environment`     | 开始应用 Node.js 风格的文件系统到 compiler 对象，以方便后续的文件寻找和读取。 |
| `entry-option`    | 读取配置的 `Entrys`，为每个 `Entry` 实例化一个对应的 `EntryPlugin`，为后面该 `Entry` 的递归解析工作做准备。 |
| `after-plugins`   | 调用完所有内置的和配置的插件的 `apply` 方法。                |
| `after-resolvers` | 根据配置初始化完 `resolver`，`resolver` 负责在文件系统中寻找指定路径的文件。 |

