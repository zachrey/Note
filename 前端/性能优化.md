# 性能优化

## HTTP 的缓存
HTTP 的缓存分为两种：强缓存和协商缓存

### 强缓存
浏览器会优先判断是否命中强缓存，如果命中就不会发出请求，也就是不会走协商缓存了。

强缓存涉及的两个字段： `expires`和`cache-control`

如果命中缓存，返回状态码为 `200`

#### expires

当浏览器第一次向服务端请求资源时，服务端可以在响应头中添加`expires`和`cache-control`字段来实现强缓存。

`expires` 的值为过期时间，例如：`expires: Wed, 11 Sep 2019 16:12:18 GMT`

当浏览器再向服务端发起请求是，浏览器会对比**本地时间**是否在`expires`设置的时间**之前**，如果是，就直接读取浏览器中的缓存，如果不是就发送请求。

**拿本地时间进行对比，是有缺陷的。当本地时间被修改，可能对比永远失败或者成功，所有 HTTP1.1 就添加了 cache-control 字段用来代替 expires 字段**

如今如果还在使用`expires`字段唯一的目的就是向下兼容。

#### cache-control
`cache-control`能做的`expires`不一定能做，但是`expires`能做的`cache-control`一定能做。

`cache-control`的值有很多，举🌰: 

```shell
cache-control: max-age=31536000
```
* max-age 值为时间长度，单位是秒，意味着该资源在XXX秒以内都是有效的，完美地规避了时间戳带来的潜在问题。

```shell
cache-control: max-age=3600, s-maxage=31536000
```
* s-maxage 优先级高于 max-age，两者同时出现时，优先考虑 s-maxage。如果 s-maxage 未过期，则向代理服务器请求其缓存内容。 

s-maxage 用来表明代理服务器是可以缓存资源的，并设置了缓存时间长度。

* public 与 private
来代表资源是否能被代理服务器缓存，默认值为`private`，表示只能浏览器缓存，不允许代理服务器缓存。

可以设置`public`来允许服务器缓存，如果设置了`s-maxage`就会默认为`public`。

* no-store与no-cache

no-cache 绕开了浏览器：我们为资源设置了 no-cache 后，每一次发起请求都不会再去询问浏览器的缓存情况，而是直接向服务端去确认该资源是否过期（走协商缓存）。

no-store 比较绝情，顾名思义就是不使用任何缓存策略。在 no-cache 的基础上，它连服务端的缓存确认也绕开了，只允许你直接向服务端发送请求、并下载完整的响应。

### 协商缓存
协商缓存的实现: 从 `Last-Modified` 到 `Etag`

协商缓存成功，服务端会返回状态码`304`，然后将资源重定向到浏览器的缓存。

#### Last-Modified

Last-Modified 是一个时间戳，如果我们启用了协商缓存，它会在首次请求时随着 Response Headers 返回：
```shell
Last-Modified: Fri, 27 Oct 2017 06:35:57 GMT
```
如果我们再次请求资源，请求头会添加上`If-Modified-Since`字段，它的值，就是服务端返回的`Last-Modified`的时间戳。
```shell
If-Modified-Since: Fri, 27 Oct 2017 06:35:57 GMT
```
服务器接收到这个时间戳后，会比对该时间戳和资源在服务器上的最后修改时间是否一致，从而判断资源是否发生了变化。如果发生了变化，服务端会在响应头中添加`Last-Modified`来表示，文件最后变更的时间。

**缺陷**

* 我们编辑了文件，但文件的内容没有改变。服务端并不清楚我们是否真正改变了文件，它仍然通过最后编辑时间进行判断。因此这个资源在再次被请求时，会被当做新资源，进而引发一次完整的响应——不该重新请求的时候，也会重新请求。


* 当我们修改文件的速度过快时（比如花了 100ms 完成了改动），由于 If-Modified-Since 只能检查到以秒为最小计量单位的时间差，所以它是感知不到这个改动的——该重新请求的时候，反而没有重新请求了。

这两个场景其实指向了同一个 bug——服务器并没有正确感知文件的变化。为了解决这样的问题，Etag 作为 Last-Modified 的补充出现了。

#### Etag
Etag 是由服务器为每个资源生成的唯一的标识字符串，这个标识字符串是基于文件内容编码的，只要文件内容不同，它们对应的 Etag 就是不同的，反之亦然。因此 Etag 能够精准地感知文件的变化。

Etag 和 Last-Modified 类似，当首次请求时，我们会在响应头里获取到一个最初的标识符字符串，举个🌰，它可以是这样的：

```shell
ETag: W/"2a3b-1602480f459"
```
那么下一次请求时，请求头里就会带上一个值相同的、名为 if-None-Match 的字符串供服务端比对了：
```shell
If-None-Match: W/"2a3b-1602480f459"
```
Etag 的生成过程需要服务器额外付出开销，会影响服务端的性能，这是它的弊端。因此启用 Etag 需要我们审时度势。正如我们刚刚所提到的——Etag 并不能替代 Last-Modified，它只能作为 Last-Modified 的补充和强化存在。 Etag 在感知文件变化上比 Last-Modified 更加准确，优先级也更高。当 Etag 和 Last-Modified 同时存在时，以 Etag 为准。



